// Package main implements a code generator for a Win32 language projection.
package main

import (
	"encoding/binary"
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"

	"github.com/go-win/go-windows/internal/winmd"
)

func typename(name string) string {
	if len(name) > 0 {
		// Leading underscores in typenames will need to be removed.
		for i := 0; name[0] == '_'; i++ {
			name = name[1:]
			if len(name) == 0 {
				return fmt.Sprintf("UNNAMED%d", i)
			}
		}
		// Names that start with lowercase letters should be made all
		// uppercase.
		if name[0] >= 'a' && name[0] <= 'z' {
			name = strings.ToUpper(name)
		}
		if name[0] >= '0' && name[0] <= '9' {
			name = "X" + name
		}
	}
	return name
}

func gen(f *winmd.File) error {
	type EnumValue struct {
		Name string
		Type winmd.CorElementType
		Data []byte
	}

	type Enum struct {
		Namespace string
		Name      string
		Values    []*EnumValue
	}

	type StructField struct {
		Name string
	}

	type Struct struct {
		Namespace string
		Name      string
		Fields    []StructField
	}

	type Namespace struct {
		Enums   []*Enum
		Structs []*Struct
	}

	var systemEnum *winmd.TypeRef
	var systemValueType *winmd.TypeRef

	namespaces := map[string]Namespace{}

	enumValueMap := map[*winmd.Field]*EnumValue{}

	for i := range f.TypeRef {
		ref := &f.TypeRef[i]
		if ref.Namespace == "System" {
			if ref.Name == "Enum" {
				systemEnum = ref
			} else if ref.Name == "ValueType" {
				systemValueType = ref
			}
		}
	}

	if systemEnum == nil {
		return errors.New("expected to find System.Enum in typeref table")
	}

	for i := range f.TypeDef {
		def := &f.TypeDef[i]
		fieldEnd := len(f.Field)
		methodEnd := len(f.MethodDef)
		if i+1 < len(f.TypeDef) {
			fieldEnd = int(f.TypeDef[i+1].FieldList) - 1
			methodEnd = int(f.TypeDef[i+1].MethodList) - 1
		}
		fields := f.Field[def.FieldList-1 : fieldEnd]
		if def.Extends.Lookup(f) == systemEnum {
			enum := &Enum{
				Namespace: string(def.Namespace),
				Name:      string(def.Name),
			}
			for i := range fields {
				field := &fields[i]
				if field.Flags.Special() && field.Name == "value__" {
					continue
				}
				value := &EnumValue{
					Name: string(field.Name),
				}
				enum.Values = append(enum.Values, value)
				enumValueMap[field] = value
			}
			namespace := namespaces[string(def.Namespace)]
			namespace.Enums = append(namespace.Enums, enum)
			namespaces[string(def.Namespace)] = namespace
		}
		if def.Extends.Lookup(f) == systemValueType {
			if string(def.Namespace) == "" {
				log.Println("Warning: not handling nested structure ", def.Name)
				continue
			}
			struc := &Struct{
				Namespace: string(def.Namespace),
				Name:      string(def.Name),
			}
			for i := range fields {
				field := &fields[i]
				struc.Fields = append(struc.Fields, StructField{
					Name: string(field.Name),
				})
			}
			namespace := namespaces[string(def.Namespace)]
			namespace.Structs = append(namespace.Structs, struc)
			namespaces[string(def.Namespace)] = namespace
		}
		_ = methodEnd
	}

	for i := range f.Constant {
		constant := &f.Constant[i]
		switch parent := constant.Parent.Lookup(f).(type) {
		case *winmd.Field:
			enumValue, ok := enumValueMap[parent]
			if !ok {
				break
			}
			enumValue.Type = constant.Type
			enumValue.Data = constant.Value
		}
	}

	for namespace, decls := range namespaces {
		ns := strings.Split(strings.ToLower(namespace), ".")
		pkg := ns[len(ns)-1]
		folderpath := strings.ReplaceAll(strings.ToLower(namespace), ".", "/")
		if err := os.MkdirAll(folderpath, 0755); err != nil {
			return err
		}

		names := map[string]*Enum{}
		conflictingEnums := map[*Enum]struct{}{}
		nameMap := map[string]string{}
		genNameSet := map[string]struct{}{}

		for _, enum := range decls.Enums {
			for _, value := range enum.Values {
				if other, ok := names[typename(value.Name)]; ok {
					conflictingEnums[enum] = struct{}{}
					conflictingEnums[other] = struct{}{}
				}
				names[typename(value.Name)] = enum
			}
		}

		enumpath := folderpath + "/enums.go"
		fmt.Println("Generating", enumpath)
		enumf, err := os.Create(enumpath)
		if err != nil {
			return err
		}
		fmt.Fprintf(enumf, "// AUTOGENERATED - DO NOT EDIT\n// Generated by go-windows.\n\n// Package %s implements the %s namespace.\npackage %s\n\n", pkg, namespace, pkg)
		for _, enum := range decls.Enums {
			name := typename(enum.Name)
			nameMap[enum.Name] = name
			genNameSet[name] = struct{}{}
			if len(enum.Values) == 0 {
				fmt.Fprintf(enumf, "type %s int\n\n", name)
				continue
			}
			switch enum.Values[0].Type {
			case winmd.CorElementTypeUint16:
				fmt.Fprintf(enumf, "type %s uint16\n\n", name)
			case winmd.CorElementTypeUint32:
				fmt.Fprintf(enumf, "type %s uint32\n\n", name)
			case winmd.CorElementTypeInt32:
				fmt.Fprintf(enumf, "type %s int32\n\n", name)
			default:
				log.Fatalf("Unexpected enum type for %s.%s.%s: %#v\n", enum.Namespace, enum.Name, enum.Values[0].Name, enum.Values[0].Type)
			}
			fmt.Fprintf(enumf, "const (\n")
			prefix := ""
			if _, ok := conflictingEnums[enum]; ok {
				prefix = name + "_"
			}
			for _, value := range enum.Values {
				valuename := prefix + typename(value.Name)
				nameMap[value.Name] = valuename
				genNameSet[valuename] = struct{}{}
				switch value.Type {
				case winmd.CorElementTypeUint16:
					fmt.Fprintf(enumf, "\t%s %s = %d\n", valuename, name, binary.LittleEndian.Uint16(value.Data))
				case winmd.CorElementTypeUint32:
					fmt.Fprintf(enumf, "\t%s %s = %d\n", valuename, name, binary.LittleEndian.Uint32(value.Data))
				case winmd.CorElementTypeInt32:
					fmt.Fprintf(enumf, "\t%s %s = %d\n", valuename, name, int32(binary.LittleEndian.Uint32(value.Data)))
				default:
					log.Fatalf("Unexpected enum type for %s.%s.%s: %#v\n", enum.Namespace, enum.Name, value.Name, value.Type)
				}
			}
			fmt.Fprintf(enumf, ")\n\n")
		}
		if err := enumf.Sync(); err != nil {
			return err
		}
		if err := enumf.Close(); err != nil {
			return err
		}

		structpath := folderpath + "/structs.go"
		fmt.Println("Generating", structpath)
		structf, err := os.Create(structpath)
		if err != nil {
			return err
		}
		fmt.Fprintf(structf, "// AUTOGENERATED - DO NOT EDIT\n// Generated by go-windows.\n\n// Package %s implements the %s namespace.\npackage %s\n\n", pkg, namespace, pkg)
		for _, struc := range decls.Structs {
			name := typename(struc.Name)
			for {
				if _, ok := genNameSet[name]; !ok {
					break
				}
				name += "_"
			}
			nameMap[struc.Name] = name
			genNameSet[name] = struct{}{}
			fmt.Fprintf(structf, "type %s struct {\n", name)
			fieldNameSet := map[string]struct{}{}
			for _, field := range struc.Fields {
				barename := typename(field.Name)
				fieldname := barename
				for i := 0; ; i++ {
					if _, ok := fieldNameSet[fieldname]; !ok {
						break
					}
					fieldname = fmt.Sprintf("%s%d", barename, i)
				}
				fieldNameSet[fieldname] = struct{}{}
				fmt.Fprintf(structf, "\t%s int\n", fieldname)
			}
			fmt.Fprintf(structf, "}\n\n")
		}
		if err := structf.Sync(); err != nil {
			return err
		}
		if err := structf.Close(); err != nil {
			return err
		}
	}

	return exec.Command("go", "fmt", "./...").Run()
}

func main() {
	flag.Parse()
	for _, arg := range flag.Args() {
		f, err := os.Open(arg)
		if err != nil {
			log.Fatalln(err)
		}
		w, err := winmd.Load(f)
		if err != nil {
			log.Fatalln(err)
		}
		if err := gen(w); err != nil {
			log.Fatalln(err)
		}
	}
}
